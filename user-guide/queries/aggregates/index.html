<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../../img/favicon.ico">
  <title>Aggregates - Beam Documentation</title>

  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../../css/highlight.css">
  <link href="../../../theme/css/beam.css" rel="stylesheet">
<link rel="stylesheet" type="text/css" href="css/beam.css"/>

  
  <script>
    // Current page data
    var mkdocs_page_name = "Aggregates";
    var mkdocs_page_input_path = "user-guide/queries/aggregates.md";
    var mkdocs_page_url = "/user-guide/queries/aggregates/";
  </script>
  
  <script src="../../../js/jquery-2.1.1.min.js"></script>
  <script src="../../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../../.." class="icon icon-home"> Beam Documentation</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../../..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../../about/faq/">Frequently Asked Questions</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">User Guide</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../getting-started/">Getting Started</a>
                </li>
                <li class="">
                    
    <a class="" href="../../models/">Models</a>
                </li>
                <li class="">
                    
    <a class="" href="../../databases/">Databases</a>
                </li>
                <li class="">
                    
    <a class="" href="../basic/">Basic Queries</a>
                </li>
                <li class="">
                    
    <a class="" href="../select/">More complex SELECTs</a>
                </li>
                <li class="">
                    
    <a class="" href="../ordering/">Ordering</a>
                </li>
                <li class="">
                    
    <a class="" href="../relationships/">Relationships</a>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">Aggregates</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#simple-aggregate-usage">Simple aggregate usage</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#adding-a-group-by-clause">Adding a GROUP BY clause</a></li>
        
        </ul>
    

    <li class="toctree-l3"><a href="#sql-compatibility">SQL compatibility</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#the-having-clause">The HAVING clause</a></li>
        
        </ul>
    

    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../combining-queries/">Combining queries</a>
                </li>
                <li class="">
                    
    <a class="" href="../window-functions/">Window functions</a>
                </li>
                <li class="">
                    
    <a class="" href="../advanced-features/">Advanced features</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Schema management</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../../schema-guide/migrations/">The Migrations Framework</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../schema-guide/tool/">The beam-migrate tool</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../schema-guide/supported/">Supported migrations</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Backends</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../backends/beam-postgres/">beam-postgres</a>
                </li>
                <li class="">
                    
    <a class="" href="../../backends/beam-sqlite/">beam-sqlite</a>
                </li>
                <li class="">
                    
    <a class="" href="../../custom-backends/">Writing a Custom Backend</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">Reference</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../../reference/models/">Models</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../reference/expression/">Expressions</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../reference/queries/">Queries</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../reference/extensibility/">Extending</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">About</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../../about/compatibility/">Compatibility Matrix</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../about/license/">License</a>
                </li>
                <li class="">
                    
    <a class="" href="../../../about/release-notes/">Release Notes</a>
                </li>
    </ul>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../..">Beam Documentation</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../..">Docs</a> &raquo;</li>
    
      
        
          <li>User Guide &raquo;</li>
        
      
    
    <li>Aggregates</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p>You can use the <code>aggregate_</code> function to group your result set and compute
aggregates within the group. You can think of <code>aggregate_</code> as a souped up
version of Haskell's <code>groupBy</code>.</p>
<p>You use <code>aggregate_</code> by specifying an underlying query to run and a function
that produces an aggregation projection. An aggregation projection is either a
value of type <code>QAgg syntax s a</code>, a value of type <code>QGroupExpr syntax s a</code>, or a
tuple of such values. Any <code>QGenExpr</code> that uses an aggregate function is
automatically assigned the <code>QAgg syntax s a</code> type. Any <code>QGenExpr</code> that contains
the <code>group_</code> combinator is given the type <code>QGroupExpr</code>.</p>
<p>During query generation, the expressions of type <code>QGroupExpr</code> are added to the
<code>GROUP BY</code> clause, and expressions of type <code>QAgg</code> are treated as aggregation to
be computed.</p>
<p>The result of the <code>aggregate_</code> lifts all the <code>QAgg</code>s and <code>QGroupExpr</code>s to
'regular' value-level <code>QExpr</code>s, so the result of <code>aggregate_</code> can be used in
expressions as usual.</p>
<h2 id="simple-aggregate-usage">Simple aggregate usage</h2>
<p>Suppose we wanted to count the number of genres in our database.</p>
<p>
                <div class="code-nav-container">
                    
        <ul class="nav nav-tabs">
            
        <li class="nav-item">
            <a href="#tab-0-haskell" aria-controls="tab-0-haskell" role="tab" data-toggle="tab" data-lang="haskell">Haskell</a>
        </li>
    
        <li class="nav-item">
            <a href="#tab-0-sqlite3" aria-controls="tab-0-sqlite3" role="tab" data-toggle="tab" data-lang="sqlite3">Sqlite3</a>
        </li>
    
        <li class="nav-item">
            <a href="#tab-0-postgres" aria-controls="tab-0-postgres" role="tab" data-toggle="tab" data-lang="postgres">Postgres</a>
        </li>
    
        </ul>
    
        <div class="tab-content">
            
        <div role="tabpanel" class="tab-pane active" id="tab-0-haskell">
            <pre><code  class="haskell">aggregate_ (\_ -&gt; countAll_) (all_ (genre chinookDb))
</code></pre>
        </div>
    
        <div role="tabpanel" class="tab-pane " id="tab-0-sqlite3">
            <pre><code  class="sqlite3">SELECT COUNT(*) AS &quot;res0&quot;
FROM &quot;Genre&quot; AS &quot;t0&quot;
</code></pre>
        </div>
    
        <div role="tabpanel" class="tab-pane " id="tab-0-postgres">
            <pre><code  class="postgres">SELECT COUNT(*) AS &quot;res0&quot;
FROM &quot;Genre&quot; AS &quot;t0&quot;
</code></pre>
        </div>
    
        </div>
    
                </div>
                    </p>
<h3 id="adding-a-group-by-clause">Adding a GROUP BY clause</h3>
<p>Above, SQL used the default grouping, which puts all rows in one group. We can
also specify columns and expressions to group by. For example, if we wanted to
count the number of tracks for each genre, we can use the <code>group_</code> function to
group by the genre.</p>
<p>
                <div class="code-nav-container">
                    
        <ul class="nav nav-tabs">
            
        <li class="nav-item">
            <a href="#tab-1-haskell" aria-controls="tab-1-haskell" role="tab" data-toggle="tab" data-lang="haskell">Haskell</a>
        </li>
    
        <li class="nav-item">
            <a href="#tab-1-sqlite3" aria-controls="tab-1-sqlite3" role="tab" data-toggle="tab" data-lang="sqlite3">Sqlite3</a>
        </li>
    
        <li class="nav-item">
            <a href="#tab-1-postgres" aria-controls="tab-1-postgres" role="tab" data-toggle="tab" data-lang="postgres">Postgres</a>
        </li>
    
        </ul>
    
        <div class="tab-content">
            
        <div role="tabpanel" class="tab-pane active" id="tab-1-haskell">
            <pre><code  class="haskell">aggregate_ (\(genre, track) -&gt; (group_ genre, as_ @Int $ count_ (trackId track)))
           ((,) &lt;$&gt; all_ (genre chinookDb) &lt;*&gt; all_ (track chinookDb))
</code></pre>
        </div>
    
        <div role="tabpanel" class="tab-pane " id="tab-1-sqlite3">
            <pre><code  class="sqlite3">SELECT &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res0&quot;,
       &quot;t0&quot;.&quot;Name&quot; AS &quot;res1&quot;,
       COUNT(&quot;t1&quot;.&quot;TrackId&quot;) AS &quot;res2&quot;
FROM &quot;Genre&quot; AS &quot;t0&quot;
INNER JOIN &quot;Track&quot; AS &quot;t1&quot;
GROUP BY &quot;t0&quot;.&quot;GenreId&quot;,
         &quot;t0&quot;.&quot;Name&quot;
</code></pre>
        </div>
    
        <div role="tabpanel" class="tab-pane " id="tab-1-postgres">
            <pre><code  class="postgres">SELECT &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res0&quot;,
       &quot;t0&quot;.&quot;Name&quot; AS &quot;res1&quot;,
       COUNT(&quot;t1&quot;.&quot;TrackId&quot;) AS &quot;res2&quot;
FROM &quot;Genre&quot; AS &quot;t0&quot;
INNER JOIN &quot;Track&quot; AS &quot;t1&quot;
GROUP BY &quot;t0&quot;.&quot;GenreId&quot;,
         &quot;t0&quot;.&quot;Name&quot;
</code></pre>
        </div>
    
        </div>
    
                </div>
                    </p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p><code>count_</code> can return any <code>Integral</code> type. Adding the explicit <code>as_ @Int</code> above 
prevents an ambiguous type error.</p>
</div>
<h2 id="sql-compatibility">SQL compatibility</h2>
<p>Above, we demonstrated the use of <code>count_</code> and <code>countAll_</code> which map to the
appropriate SQL aggregates. Beam supports all of the other standard SQL92
aggregates.</p>
<p>In general, SQL aggregates are named similarly in beam and SQL. As usual, the
aggregate function in beam is suffixed by an underscore. For example, <code>sum_</code>
corresponds to the SQL aggregate <code>SUM</code>.</p>
<p>SQL also allows you to specify set quantifiers for each aggregate. Beam supports
these as well. By convention, versions of aggregates that take in an optional
set quantifier are suffixed by <code>Over</code>. For example <code>SUM(DISTINCT x)</code> can be
written <code>sumOver_ distinctInGroup_ x</code>. The universally quantified version of
each aggregate is obtained by using the <code>allInGroup_</code> quantifier. Thus, <code>sum_ ==
sumOver_ allInGroup_</code>. Because <code>ALL</code> is the default set quantifier, beam does
not typically generate it in queries. If, for some reason, you would like beam
to be explicit about it, you can use the <code>allInGroupExplicitly_</code> quantifier.</p>
<p>
                <div class="code-nav-container">
                    
        <ul class="nav nav-tabs">
            
        <li class="nav-item">
            <a href="#tab-2-haskell" aria-controls="tab-2-haskell" role="tab" data-toggle="tab" data-lang="haskell">Haskell</a>
        </li>
    
        <li class="nav-item">
            <a href="#tab-2-sqlite3" aria-controls="tab-2-sqlite3" role="tab" data-toggle="tab" data-lang="sqlite3">Sqlite3</a>
        </li>
    
        <li class="nav-item">
            <a href="#tab-2-postgres" aria-controls="tab-2-postgres" role="tab" data-toggle="tab" data-lang="postgres">Postgres</a>
        </li>
    
        </ul>
    
        <div class="tab-content">
            
        <div role="tabpanel" class="tab-pane active" id="tab-2-haskell">
            <pre><code  class="haskell">aggregate_ (\(genre, track) -&gt;
              ( group_ genre
              , as_ @Int $ countOver_ distinctInGroup_ (trackUnitPrice track)
              , sumOver_ allInGroupExplicitly_ (trackMilliseconds track) `div_` 1000 )) $
           ((,) &lt;$&gt; all_ (genre chinookDb) &lt;*&gt; all_ (track chinookDb))
</code></pre>
        </div>
    
        <div role="tabpanel" class="tab-pane " id="tab-2-sqlite3">
            <pre><code  class="sqlite3">SELECT &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res0&quot;,
       &quot;t0&quot;.&quot;Name&quot; AS &quot;res1&quot;,
       COUNT(DISTINCT &quot;t1&quot;.&quot;UnitPrice&quot;) AS &quot;res2&quot;,
       (SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (?) AS &quot;res3&quot;
FROM &quot;Genre&quot; AS &quot;t0&quot;
INNER JOIN &quot;Track&quot; AS &quot;t1&quot;
GROUP BY &quot;t0&quot;.&quot;GenreId&quot;,
         &quot;t0&quot;.&quot;Name&quot;
</code></pre>
        </div>
    
        <div role="tabpanel" class="tab-pane " id="tab-2-postgres">
            <pre><code  class="postgres">SELECT &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res0&quot;,
       &quot;t0&quot;.&quot;Name&quot; AS &quot;res1&quot;,
       COUNT(DISTINCT &quot;t1&quot;.&quot;UnitPrice&quot;) AS &quot;res2&quot;,
       (SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (1000) AS &quot;res3&quot;
FROM &quot;Genre&quot; AS &quot;t0&quot;
INNER JOIN &quot;Track&quot; AS &quot;t1&quot;
GROUP BY &quot;t0&quot;.&quot;GenreId&quot;,
         &quot;t0&quot;.&quot;Name&quot;
</code></pre>
        </div>
    
        </div>
    
                </div>
                    </p>
<p>The <code>beam-core</code> library supports the standard SQL aggregation functions.
Individual backends are likely to support the full range of aggregates available
on that backend (if not, please send a bug report).</p>
<table>
<thead>
<tr>
<th align="left">SQL Aggregate</th>
<th align="center">Relevant standard</th>
<th align="left">Unquantified beam function</th>
<th align="left">Quantified beam function</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">SUM</td>
<td align="center">SQL92</td>
<td align="left"><code>sum_</code></td>
<td align="left"><code>sumOver_</code></td>
</tr>
<tr>
<td align="left">MIN</td>
<td align="center">SQL92</td>
<td align="left"><code>min_</code></td>
<td align="left"><code>minOver_</code></td>
</tr>
<tr>
<td align="left">MAX</td>
<td align="center">SQL92</td>
<td align="left"><code>max_</code></td>
<td align="left"><code>maxOver_</code></td>
</tr>
<tr>
<td align="left">AVG</td>
<td align="center">SQL92</td>
<td align="left"><code>avg_</code></td>
<td align="left"><code>avgOver_</code></td>
</tr>
<tr>
<td align="left">COUNT(x)</td>
<td align="center">SQL92</td>
<td align="left"><code>count_</code></td>
<td align="left"><code>countOver_</code></td>
</tr>
<tr>
<td align="left">COUNT(*)</td>
<td align="center">SQL92</td>
<td align="left"><code>countAll_</code></td>
<td align="left">N/A</td>
</tr>
<tr>
<td align="left">EVERY(x)</td>
<td align="center">SQL99</td>
<td align="left"><code>every_</code></td>
<td align="left"><code>everyOver_</code></td>
</tr>
<tr>
<td align="left">ANY(x)/SOME(x)</td>
<td align="center">SQL99</td>
<td align="left"><code>any_</code>, <code>some_</code></td>
<td align="left"><code>anyOver_</code>, <code>someOver_</code></td>
</tr>
</tbody>
</table>
<h3 id="the-having-clause">The <code>HAVING</code> clause</h3>
<p>SQL allows users to specify a <code>HAVING</code> condition to filter results based on the
computed result of an aggregate. Beam fully supports <code>HAVIVG</code> clauses, but does
not use any special syntax. Simply use <code>filter_</code> or <code>guard_</code> as usual, and beam
will add a <code>HAVING</code> clause if it forms legal SQL. Otherwise, beam will create a
subselect and add a <code>WHERE</code> clause. Either way, this is transparent to the user.</p>
<p>
                <div class="code-nav-container">
                    
        <ul class="nav nav-tabs">
            
        <li class="nav-item">
            <a href="#tab-3-haskell" aria-controls="tab-3-haskell" role="tab" data-toggle="tab" data-lang="haskell">Haskell</a>
        </li>
    
        <li class="nav-item">
            <a href="#tab-3-sqlite3" aria-controls="tab-3-sqlite3" role="tab" data-toggle="tab" data-lang="sqlite3">Sqlite3</a>
        </li>
    
        <li class="nav-item">
            <a href="#tab-3-postgres" aria-controls="tab-3-postgres" role="tab" data-toggle="tab" data-lang="postgres">Postgres</a>
        </li>
    
        </ul>
    
        <div class="tab-content">
            
        <div role="tabpanel" class="tab-pane active" id="tab-3-haskell">
            <pre><code  class="haskell">-- Only return results for genres whose total track length is over 5 minutes
filter_ (\(genre, distinctPriceCount, totalTrackLength) -&gt; totalTrackLength &gt;=. 300000) $
aggregate_ (\(genre, track) -&gt;
              ( group_ genre
              , as_ @Int $ countOver_ distinctInGroup_ (trackUnitPrice track)
              , sumOver_ allInGroupExplicitly_ (trackMilliseconds track) `div_` 1000 )) $
           ((,) &lt;$&gt; all_ (genre chinookDb) &lt;*&gt; all_ (track chinookDb))
</code></pre>
        </div>
    
        <div role="tabpanel" class="tab-pane " id="tab-3-sqlite3">
            <pre><code  class="sqlite3">SELECT &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res0&quot;,
       &quot;t0&quot;.&quot;Name&quot; AS &quot;res1&quot;,
       COUNT(DISTINCT &quot;t1&quot;.&quot;UnitPrice&quot;) AS &quot;res2&quot;,
       (SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (?) AS &quot;res3&quot;
FROM &quot;Genre&quot; AS &quot;t0&quot;
INNER JOIN &quot;Track&quot; AS &quot;t1&quot;
GROUP BY &quot;t0&quot;.&quot;GenreId&quot;,
         &quot;t0&quot;.&quot;Name&quot;
HAVING ((SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (?))&gt;=(?)
</code></pre>
        </div>
    
        <div role="tabpanel" class="tab-pane " id="tab-3-postgres">
            <pre><code  class="postgres">SELECT &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res0&quot;,
       &quot;t0&quot;.&quot;Name&quot; AS &quot;res1&quot;,
       COUNT(DISTINCT &quot;t1&quot;.&quot;UnitPrice&quot;) AS &quot;res2&quot;,
       (SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (1000) AS &quot;res3&quot;
FROM &quot;Genre&quot; AS &quot;t0&quot;
INNER JOIN &quot;Track&quot; AS &quot;t1&quot;
GROUP BY &quot;t0&quot;.&quot;GenreId&quot;,
         &quot;t0&quot;.&quot;Name&quot;
HAVING ((SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (1000)) &gt;= (300000)
</code></pre>
        </div>
    
        </div>
    
                </div>
                    </p>
<p>Beam will also handle the <code>filter_</code> correctly in the presence of more
complicated queries. For example, we can now join our aggregate on genres back
over tracks.</p>
<p>
                <div class="code-nav-container">
                    
        <ul class="nav nav-tabs">
            
        <li class="nav-item">
            <a href="#tab-4-haskell" aria-controls="tab-4-haskell" role="tab" data-toggle="tab" data-lang="haskell">Haskell</a>
        </li>
    
        <li class="nav-item">
            <a href="#tab-4-sqlite3" aria-controls="tab-4-sqlite3" role="tab" data-toggle="tab" data-lang="sqlite3">Sqlite3</a>
        </li>
    
        <li class="nav-item">
            <a href="#tab-4-postgres" aria-controls="tab-4-postgres" role="tab" data-toggle="tab" data-lang="postgres">Postgres</a>
        </li>
    
        </ul>
    
        <div class="tab-content">
            
        <div role="tabpanel" class="tab-pane active" id="tab-4-haskell">
            <pre><code  class="haskell">-- Only return results for genres whose total track length is over 5 minutes
filter_ (\(genre, track, distinctPriceCount, totalTrackLength) -&gt; totalTrackLength &gt;=. 300000) $
do (genre, priceCnt, trackLength) &lt;-
            aggregate_ (\(genre, track) -&gt;
                          ( group_ genre
                          , as_ @Int $ countOver_ distinctInGroup_ (trackUnitPrice track)
                          , sumOver_ allInGroupExplicitly_ (trackMilliseconds track) `div_` 1000 )) $
            ((,) &lt;$&gt; all_ (genre chinookDb) &lt;*&gt; all_ (track chinookDb))
   track &lt;- join_ (track chinookDb) (\track -&gt; trackGenreId track ==. just_ (pk genre))
   pure (genre, track, priceCnt, trackLength)
</code></pre>
        </div>
    
        <div role="tabpanel" class="tab-pane " id="tab-4-sqlite3">
            <pre><code  class="sqlite3">SELECT &quot;t0&quot;.&quot;res0&quot; AS &quot;res0&quot;,
       &quot;t0&quot;.&quot;res1&quot; AS &quot;res1&quot;,
       &quot;t1&quot;.&quot;TrackId&quot; AS &quot;res2&quot;,
       &quot;t1&quot;.&quot;Name&quot; AS &quot;res3&quot;,
       &quot;t1&quot;.&quot;AlbumId&quot; AS &quot;res4&quot;,
       &quot;t1&quot;.&quot;MediaTypeId&quot; AS &quot;res5&quot;,
       &quot;t1&quot;.&quot;GenreId&quot; AS &quot;res6&quot;,
       &quot;t1&quot;.&quot;Composer&quot; AS &quot;res7&quot;,
       &quot;t1&quot;.&quot;Milliseconds&quot; AS &quot;res8&quot;,
       &quot;t1&quot;.&quot;Bytes&quot; AS &quot;res9&quot;,
       &quot;t1&quot;.&quot;UnitPrice&quot; AS &quot;res10&quot;,
       &quot;t0&quot;.&quot;res2&quot; AS &quot;res11&quot;,
       &quot;t0&quot;.&quot;res3&quot; AS &quot;res12&quot;
FROM
  (SELECT &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res0&quot;,
          &quot;t0&quot;.&quot;Name&quot; AS &quot;res1&quot;,
          COUNT(DISTINCT &quot;t1&quot;.&quot;UnitPrice&quot;) AS &quot;res2&quot;,
          (SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (?) AS &quot;res3&quot;
   FROM &quot;Genre&quot; AS &quot;t0&quot;
   INNER JOIN &quot;Track&quot; AS &quot;t1&quot;
   GROUP BY &quot;t0&quot;.&quot;GenreId&quot;,
            &quot;t0&quot;.&quot;Name&quot;) AS &quot;t0&quot;
INNER JOIN &quot;Track&quot; AS &quot;t1&quot; ON (&quot;t1&quot;.&quot;GenreId&quot;)=(&quot;t0&quot;.&quot;res0&quot;)
WHERE (&quot;t0&quot;.&quot;res3&quot;)&gt;=(?)
</code></pre>
        </div>
    
        <div role="tabpanel" class="tab-pane " id="tab-4-postgres">
            <pre><code  class="postgres">SELECT &quot;t0&quot;.&quot;res0&quot; AS &quot;res0&quot;,
       &quot;t0&quot;.&quot;res1&quot; AS &quot;res1&quot;,
       &quot;t1&quot;.&quot;TrackId&quot; AS &quot;res2&quot;,
       &quot;t1&quot;.&quot;Name&quot; AS &quot;res3&quot;,
       &quot;t1&quot;.&quot;AlbumId&quot; AS &quot;res4&quot;,
       &quot;t1&quot;.&quot;MediaTypeId&quot; AS &quot;res5&quot;,
       &quot;t1&quot;.&quot;GenreId&quot; AS &quot;res6&quot;,
       &quot;t1&quot;.&quot;Composer&quot; AS &quot;res7&quot;,
       &quot;t1&quot;.&quot;Milliseconds&quot; AS &quot;res8&quot;,
       &quot;t1&quot;.&quot;Bytes&quot; AS &quot;res9&quot;,
       &quot;t1&quot;.&quot;UnitPrice&quot; AS &quot;res10&quot;,
       &quot;t0&quot;.&quot;res2&quot; AS &quot;res11&quot;,
       &quot;t0&quot;.&quot;res3&quot; AS &quot;res12&quot;
FROM
  (SELECT &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res0&quot;,
          &quot;t0&quot;.&quot;Name&quot; AS &quot;res1&quot;,
          COUNT(DISTINCT &quot;t1&quot;.&quot;UnitPrice&quot;) AS &quot;res2&quot;,
          (SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (1000) AS &quot;res3&quot;
   FROM &quot;Genre&quot; AS &quot;t0&quot;
   INNER JOIN &quot;Track&quot; AS &quot;t1&quot;
   GROUP BY &quot;t0&quot;.&quot;GenreId&quot;,
            &quot;t0&quot;.&quot;Name&quot;) AS &quot;t0&quot;
INNER JOIN &quot;Track&quot; AS &quot;t1&quot; ON (&quot;t1&quot;.&quot;GenreId&quot;) = (&quot;t0&quot;.&quot;res0&quot;)
WHERE (&quot;t0&quot;.&quot;res3&quot;) &gt;= (300000)
</code></pre>
        </div>
    
        </div>
    
                </div>
                    </p>
<p>The position of <code>filter_</code> changes the code generated. Above, the <code>filter_</code>
produced a <code>WHERE</code> clause on the outermost <code>SELECT</code>. If instead, we put the
<code>filter_</code> clause right outside the <code>aggregate_</code>, beam will produce a <code>HAVING</code> clause instead.</p>
<p>
                <div class="code-nav-container">
                    
        <ul class="nav nav-tabs">
            
        <li class="nav-item">
            <a href="#tab-5-haskell" aria-controls="tab-5-haskell" role="tab" data-toggle="tab" data-lang="haskell">Haskell</a>
        </li>
    
        <li class="nav-item">
            <a href="#tab-5-sqlite3" aria-controls="tab-5-sqlite3" role="tab" data-toggle="tab" data-lang="sqlite3">Sqlite3</a>
        </li>
    
        <li class="nav-item">
            <a href="#tab-5-postgres" aria-controls="tab-5-postgres" role="tab" data-toggle="tab" data-lang="postgres">Postgres</a>
        </li>
    
        </ul>
    
        <div class="tab-content">
            
        <div role="tabpanel" class="tab-pane active" id="tab-5-haskell">
            <pre><code  class="haskell">-- Only return results for genres whose total track length is over 5 minutes
do (genre, priceCnt, trackLength) &lt;-
            filter_ (\(genre, distinctPriceCount, totalTrackLength) -&gt; totalTrackLength &gt;=. 300000) $
            aggregate_ (\(genre, track) -&gt;
                          ( group_ genre
                          , as_ @Int $ countOver_ distinctInGroup_ (trackUnitPrice track)
                          , sumOver_ allInGroupExplicitly_ (trackMilliseconds track) `div_` 1000 )) $
            ((,) &lt;$&gt; all_ (genre chinookDb) &lt;*&gt; all_ (track chinookDb))
   track &lt;- join_ (track chinookDb) (\track -&gt; trackGenreId track ==. just_ (pk genre))
   pure (genre, track, priceCnt, trackLength)
</code></pre>
        </div>
    
        <div role="tabpanel" class="tab-pane " id="tab-5-sqlite3">
            <pre><code  class="sqlite3">SELECT &quot;t0&quot;.&quot;res0&quot; AS &quot;res0&quot;,
       &quot;t0&quot;.&quot;res1&quot; AS &quot;res1&quot;,
       &quot;t1&quot;.&quot;TrackId&quot; AS &quot;res2&quot;,
       &quot;t1&quot;.&quot;Name&quot; AS &quot;res3&quot;,
       &quot;t1&quot;.&quot;AlbumId&quot; AS &quot;res4&quot;,
       &quot;t1&quot;.&quot;MediaTypeId&quot; AS &quot;res5&quot;,
       &quot;t1&quot;.&quot;GenreId&quot; AS &quot;res6&quot;,
       &quot;t1&quot;.&quot;Composer&quot; AS &quot;res7&quot;,
       &quot;t1&quot;.&quot;Milliseconds&quot; AS &quot;res8&quot;,
       &quot;t1&quot;.&quot;Bytes&quot; AS &quot;res9&quot;,
       &quot;t1&quot;.&quot;UnitPrice&quot; AS &quot;res10&quot;,
       &quot;t0&quot;.&quot;res2&quot; AS &quot;res11&quot;,
       &quot;t0&quot;.&quot;res3&quot; AS &quot;res12&quot;
FROM
  (SELECT &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res0&quot;,
          &quot;t0&quot;.&quot;Name&quot; AS &quot;res1&quot;,
          COUNT(DISTINCT &quot;t1&quot;.&quot;UnitPrice&quot;) AS &quot;res2&quot;,
          (SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (?) AS &quot;res3&quot;
   FROM &quot;Genre&quot; AS &quot;t0&quot;
   INNER JOIN &quot;Track&quot; AS &quot;t1&quot;
   GROUP BY &quot;t0&quot;.&quot;GenreId&quot;,
            &quot;t0&quot;.&quot;Name&quot;
   HAVING ((SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (?))&gt;=(?)) AS &quot;t0&quot;
INNER JOIN &quot;Track&quot; AS &quot;t1&quot; ON (&quot;t1&quot;.&quot;GenreId&quot;)=(&quot;t0&quot;.&quot;res0&quot;)
</code></pre>
        </div>
    
        <div role="tabpanel" class="tab-pane " id="tab-5-postgres">
            <pre><code  class="postgres">SELECT &quot;t0&quot;.&quot;res0&quot; AS &quot;res0&quot;,
       &quot;t0&quot;.&quot;res1&quot; AS &quot;res1&quot;,
       &quot;t1&quot;.&quot;TrackId&quot; AS &quot;res2&quot;,
       &quot;t1&quot;.&quot;Name&quot; AS &quot;res3&quot;,
       &quot;t1&quot;.&quot;AlbumId&quot; AS &quot;res4&quot;,
       &quot;t1&quot;.&quot;MediaTypeId&quot; AS &quot;res5&quot;,
       &quot;t1&quot;.&quot;GenreId&quot; AS &quot;res6&quot;,
       &quot;t1&quot;.&quot;Composer&quot; AS &quot;res7&quot;,
       &quot;t1&quot;.&quot;Milliseconds&quot; AS &quot;res8&quot;,
       &quot;t1&quot;.&quot;Bytes&quot; AS &quot;res9&quot;,
       &quot;t1&quot;.&quot;UnitPrice&quot; AS &quot;res10&quot;,
       &quot;t0&quot;.&quot;res2&quot; AS &quot;res11&quot;,
       &quot;t0&quot;.&quot;res3&quot; AS &quot;res12&quot;
FROM
  (SELECT &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res0&quot;,
          &quot;t0&quot;.&quot;Name&quot; AS &quot;res1&quot;,
          COUNT(DISTINCT &quot;t1&quot;.&quot;UnitPrice&quot;) AS &quot;res2&quot;,
          (SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (1000) AS &quot;res3&quot;
   FROM &quot;Genre&quot; AS &quot;t0&quot;
   INNER JOIN &quot;Track&quot; AS &quot;t1&quot;
   GROUP BY &quot;t0&quot;.&quot;GenreId&quot;,
            &quot;t0&quot;.&quot;Name&quot;
   HAVING ((SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (1000)) &gt;= (300000)) AS &quot;t0&quot;
INNER JOIN &quot;Track&quot; AS &quot;t1&quot; ON (&quot;t1&quot;.&quot;GenreId&quot;) = (&quot;t0&quot;.&quot;res0&quot;)
</code></pre>
        </div>
    
        </div>
    
                </div>
                    </p>
<p>Due to the monadic structure, putting the filtered aggregate as the second
clause in the JOIN causes the HAVING to be floated out, because the compiler
can't prove that the conditional expression only depends on the results of the
aggregate.</p>
<p>
                <div class="code-nav-container">
                    
        <ul class="nav nav-tabs">
            
        <li class="nav-item">
            <a href="#tab-6-haskell" aria-controls="tab-6-haskell" role="tab" data-toggle="tab" data-lang="haskell">Haskell</a>
        </li>
    
        <li class="nav-item">
            <a href="#tab-6-sqlite3" aria-controls="tab-6-sqlite3" role="tab" data-toggle="tab" data-lang="sqlite3">Sqlite3</a>
        </li>
    
        <li class="nav-item">
            <a href="#tab-6-postgres" aria-controls="tab-6-postgres" role="tab" data-toggle="tab" data-lang="postgres">Postgres</a>
        </li>
    
        </ul>
    
        <div class="tab-content">
            
        <div role="tabpanel" class="tab-pane active" id="tab-6-haskell">
            <pre><code  class="haskell">-- Only return results for genres whose total track length is over 5 minutes
do track_ &lt;- all_ (track chinookDb)
   (genre, priceCnt, trackLength) &lt;-
            filter_ (\(genre, distinctPriceCount, totalTrackLength) -&gt; totalTrackLength &gt;=. 300000) $
            aggregate_ (\(genre, track) -&gt;
                          ( group_ genre
                          , as_ @Int $ countOver_ distinctInGroup_ (trackUnitPrice track)
                          , sumOver_ allInGroupExplicitly_ (trackMilliseconds track) `div_` 1000 )) $
            ((,) &lt;$&gt; all_ (genre chinookDb) &lt;*&gt; all_ (track chinookDb)) 
   guard_ (trackGenreId track_ ==. just_ (pk genre))
   pure (genre, track_, priceCnt, trackLength)
</code></pre>
        </div>
    
        <div role="tabpanel" class="tab-pane " id="tab-6-sqlite3">
            <pre><code  class="sqlite3">SELECT &quot;t1&quot;.&quot;res0&quot; AS &quot;res0&quot;,
       &quot;t1&quot;.&quot;res1&quot; AS &quot;res1&quot;,
       &quot;t0&quot;.&quot;TrackId&quot; AS &quot;res2&quot;,
       &quot;t0&quot;.&quot;Name&quot; AS &quot;res3&quot;,
       &quot;t0&quot;.&quot;AlbumId&quot; AS &quot;res4&quot;,
       &quot;t0&quot;.&quot;MediaTypeId&quot; AS &quot;res5&quot;,
       &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res6&quot;,
       &quot;t0&quot;.&quot;Composer&quot; AS &quot;res7&quot;,
       &quot;t0&quot;.&quot;Milliseconds&quot; AS &quot;res8&quot;,
       &quot;t0&quot;.&quot;Bytes&quot; AS &quot;res9&quot;,
       &quot;t0&quot;.&quot;UnitPrice&quot; AS &quot;res10&quot;,
       &quot;t1&quot;.&quot;res2&quot; AS &quot;res11&quot;,
       &quot;t1&quot;.&quot;res3&quot; AS &quot;res12&quot;
FROM &quot;Track&quot; AS &quot;t0&quot;
INNER JOIN
  (SELECT &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res0&quot;,
          &quot;t0&quot;.&quot;Name&quot; AS &quot;res1&quot;,
          COUNT(DISTINCT &quot;t1&quot;.&quot;UnitPrice&quot;) AS &quot;res2&quot;,
          (SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (?) AS &quot;res3&quot;
   FROM &quot;Genre&quot; AS &quot;t0&quot;
   INNER JOIN &quot;Track&quot; AS &quot;t1&quot;
   GROUP BY &quot;t0&quot;.&quot;GenreId&quot;,
            &quot;t0&quot;.&quot;Name&quot;) AS &quot;t1&quot;
WHERE ((&quot;t1&quot;.&quot;res3&quot;)&gt;=(?))
  AND ((&quot;t0&quot;.&quot;GenreId&quot;)=(&quot;t1&quot;.&quot;res0&quot;))
</code></pre>
        </div>
    
        <div role="tabpanel" class="tab-pane " id="tab-6-postgres">
            <pre><code  class="postgres">SELECT &quot;t1&quot;.&quot;res0&quot; AS &quot;res0&quot;,
       &quot;t1&quot;.&quot;res1&quot; AS &quot;res1&quot;,
       &quot;t0&quot;.&quot;TrackId&quot; AS &quot;res2&quot;,
       &quot;t0&quot;.&quot;Name&quot; AS &quot;res3&quot;,
       &quot;t0&quot;.&quot;AlbumId&quot; AS &quot;res4&quot;,
       &quot;t0&quot;.&quot;MediaTypeId&quot; AS &quot;res5&quot;,
       &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res6&quot;,
       &quot;t0&quot;.&quot;Composer&quot; AS &quot;res7&quot;,
       &quot;t0&quot;.&quot;Milliseconds&quot; AS &quot;res8&quot;,
       &quot;t0&quot;.&quot;Bytes&quot; AS &quot;res9&quot;,
       &quot;t0&quot;.&quot;UnitPrice&quot; AS &quot;res10&quot;,
       &quot;t1&quot;.&quot;res2&quot; AS &quot;res11&quot;,
       &quot;t1&quot;.&quot;res3&quot; AS &quot;res12&quot;
FROM &quot;Track&quot; AS &quot;t0&quot;
INNER JOIN
  (SELECT &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res0&quot;,
          &quot;t0&quot;.&quot;Name&quot; AS &quot;res1&quot;,
          COUNT(DISTINCT &quot;t1&quot;.&quot;UnitPrice&quot;) AS &quot;res2&quot;,
          (SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (1000) AS &quot;res3&quot;
   FROM &quot;Genre&quot; AS &quot;t0&quot;
   INNER JOIN &quot;Track&quot; AS &quot;t1&quot;
   GROUP BY &quot;t0&quot;.&quot;GenreId&quot;,
            &quot;t0&quot;.&quot;Name&quot;) AS &quot;t1&quot;
WHERE ((&quot;t1&quot;.&quot;res3&quot;) &gt;= (300000))
  AND ((&quot;t0&quot;.&quot;GenreId&quot;) = (&quot;t1&quot;.&quot;res0&quot;))
</code></pre>
        </div>
    
        </div>
    
                </div>
                    </p>
<p>You can prove to the compiler that the <code>filter_</code> should generate a having by
using the <code>subselect_</code> combinator.</p>
<p>
                <div class="code-nav-container">
                    
        <ul class="nav nav-tabs">
            
        <li class="nav-item">
            <a href="#tab-24-haskell" aria-controls="tab-24-haskell" role="tab" data-toggle="tab" data-lang="haskell">Haskell</a>
        </li>
    
        <li class="nav-item">
            <a href="#tab-24-sqlite3" aria-controls="tab-24-sqlite3" role="tab" data-toggle="tab" data-lang="sqlite3">Sqlite3</a>
        </li>
    
        <li class="nav-item">
            <a href="#tab-24-postgres" aria-controls="tab-24-postgres" role="tab" data-toggle="tab" data-lang="postgres">Postgres</a>
        </li>
    
        </ul>
    
        <div class="tab-content">
            
        <div role="tabpanel" class="tab-pane active" id="tab-24-haskell">
            <pre><code  class="haskell">-- Only return results for genres whose total track length is over 5 minutes
do track_ &lt;- all_ (track chinookDb)
   (genre, priceCnt, trackLength) &lt;-
            subselect_ $
            filter_ (\(genre, distinctPriceCount, totalTrackLength) -&gt; totalTrackLength &gt;=. 300000) $
            aggregate_ (\(genre, track) -&gt;
                          ( group_ genre
                          , as_ @Int $ countOver_ distinctInGroup_ (trackUnitPrice track)
                          , sumOver_ allInGroupExplicitly_ (trackMilliseconds track) `div_` 1000 )) $
            ((,) &lt;$&gt; all_ (genre chinookDb) &lt;*&gt; all_ (track chinookDb)) 
   guard_ (trackGenreId track_ ==. just_ (pk genre))
   pure (genre, track_, priceCnt, trackLength)
</code></pre>
        </div>
    
        <div role="tabpanel" class="tab-pane " id="tab-24-sqlite3">
            <pre><code  class="sqlite3">SELECT &quot;t1&quot;.&quot;res0&quot; AS &quot;res0&quot;,
       &quot;t1&quot;.&quot;res1&quot; AS &quot;res1&quot;,
       &quot;t0&quot;.&quot;TrackId&quot; AS &quot;res2&quot;,
       &quot;t0&quot;.&quot;Name&quot; AS &quot;res3&quot;,
       &quot;t0&quot;.&quot;AlbumId&quot; AS &quot;res4&quot;,
       &quot;t0&quot;.&quot;MediaTypeId&quot; AS &quot;res5&quot;,
       &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res6&quot;,
       &quot;t0&quot;.&quot;Composer&quot; AS &quot;res7&quot;,
       &quot;t0&quot;.&quot;Milliseconds&quot; AS &quot;res8&quot;,
       &quot;t0&quot;.&quot;Bytes&quot; AS &quot;res9&quot;,
       &quot;t0&quot;.&quot;UnitPrice&quot; AS &quot;res10&quot;,
       &quot;t1&quot;.&quot;res2&quot; AS &quot;res11&quot;,
       &quot;t1&quot;.&quot;res3&quot; AS &quot;res12&quot;
FROM &quot;Track&quot; AS &quot;t0&quot;
INNER JOIN
  (SELECT &quot;t0&quot;.&quot;res0&quot; AS &quot;res0&quot;,
          &quot;t0&quot;.&quot;res1&quot; AS &quot;res1&quot;,
          &quot;t0&quot;.&quot;res2&quot; AS &quot;res2&quot;,
          &quot;t0&quot;.&quot;res3&quot; AS &quot;res3&quot;
   FROM
     (SELECT &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res0&quot;,
             &quot;t0&quot;.&quot;Name&quot; AS &quot;res1&quot;,
             COUNT(DISTINCT &quot;t1&quot;.&quot;UnitPrice&quot;) AS &quot;res2&quot;,
             (SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (?) AS &quot;res3&quot;
      FROM &quot;Genre&quot; AS &quot;t0&quot;
      INNER JOIN &quot;Track&quot; AS &quot;t1&quot;
      GROUP BY &quot;t0&quot;.&quot;GenreId&quot;,
               &quot;t0&quot;.&quot;Name&quot;
      HAVING ((SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (?))&gt;=(?)) AS &quot;t0&quot;) AS &quot;t1&quot;
WHERE (&quot;t0&quot;.&quot;GenreId&quot;)=(&quot;t1&quot;.&quot;res0&quot;)
</code></pre>
        </div>
    
        <div role="tabpanel" class="tab-pane " id="tab-24-postgres">
            <pre><code  class="postgres">SELECT &quot;t1&quot;.&quot;res0&quot; AS &quot;res0&quot;,
       &quot;t1&quot;.&quot;res1&quot; AS &quot;res1&quot;,
       &quot;t0&quot;.&quot;TrackId&quot; AS &quot;res2&quot;,
       &quot;t0&quot;.&quot;Name&quot; AS &quot;res3&quot;,
       &quot;t0&quot;.&quot;AlbumId&quot; AS &quot;res4&quot;,
       &quot;t0&quot;.&quot;MediaTypeId&quot; AS &quot;res5&quot;,
       &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res6&quot;,
       &quot;t0&quot;.&quot;Composer&quot; AS &quot;res7&quot;,
       &quot;t0&quot;.&quot;Milliseconds&quot; AS &quot;res8&quot;,
       &quot;t0&quot;.&quot;Bytes&quot; AS &quot;res9&quot;,
       &quot;t0&quot;.&quot;UnitPrice&quot; AS &quot;res10&quot;,
       &quot;t1&quot;.&quot;res2&quot; AS &quot;res11&quot;,
       &quot;t1&quot;.&quot;res3&quot; AS &quot;res12&quot;
FROM &quot;Track&quot; AS &quot;t0&quot;
INNER JOIN
  (SELECT &quot;t0&quot;.&quot;res0&quot; AS &quot;res0&quot;,
          &quot;t0&quot;.&quot;res1&quot; AS &quot;res1&quot;,
          &quot;t0&quot;.&quot;res2&quot; AS &quot;res2&quot;,
          &quot;t0&quot;.&quot;res3&quot; AS &quot;res3&quot;
   FROM
     (SELECT &quot;t0&quot;.&quot;GenreId&quot; AS &quot;res0&quot;,
             &quot;t0&quot;.&quot;Name&quot; AS &quot;res1&quot;,
             COUNT(DISTINCT &quot;t1&quot;.&quot;UnitPrice&quot;) AS &quot;res2&quot;,
             (SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (1000) AS &quot;res3&quot;
      FROM &quot;Genre&quot; AS &quot;t0&quot;
      INNER JOIN &quot;Track&quot; AS &quot;t1&quot;
      GROUP BY &quot;t0&quot;.&quot;GenreId&quot;,
               &quot;t0&quot;.&quot;Name&quot;
      HAVING ((SUM(ALL &quot;t1&quot;.&quot;Milliseconds&quot;)) / (1000)) &gt;= (300000)) AS &quot;t0&quot;) AS &quot;t1&quot;
WHERE (&quot;t0&quot;.&quot;GenreId&quot;) = (&quot;t1&quot;.&quot;res0&quot;)
</code></pre>
        </div>
    
        </div>
    
                </div>
                    </p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../combining-queries/" class="btn btn-neutral float-right" title="Combining queries">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../relationships/" class="btn btn-neutral" title="Relationships"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../relationships/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../combining-queries/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>

    <script src="../../../js/theme.js"></script>
<script type="text/javascript" language="javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script type="text/javascript" language="javascript">
 $(document.body).tab();
</script>


</body>
</html>
